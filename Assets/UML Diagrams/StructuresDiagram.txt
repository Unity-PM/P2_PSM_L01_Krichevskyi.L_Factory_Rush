@enduml
@startuml
!theme mars

'Structure
interface ICanBuild {
  <<MonoBehaviour>>
  + void BuildStructure()
  + bool CheckPlace()
  --
}
interface ICanChangeLocation {
  <<MonoBehaviour>>
  + void MoveStructure()
  --
}
interface ICanRemove {
  <<MonoBehaviour>>
  + void RemoveStructure()
  --
}
interface ICanShoot {
  <<MonoBehaviour>>
  + EnemyScript enemy
  + void WatchEnemy()
  + void ShootEnemy()
  --
}
ICanShoot --> EnemyScript : use functions
interface ICanTake {
  <<MonoBehaviour>>
  + void TakeItem();
  --
}
interface IFindNeighbour {
  <<MonoBehaviour>>
  + void FindSameNeighbour()
  --
}
interface ICanProduce {
  <<MonoBehaviour>>
  + void ProduceItem()
  --
}
interface ICanTransport {
  <<MonoBehaviour>>
  + void TransportItem()
  + float transportSpeed
  --
}
interface IConsumeElectricity {
  <<MonoBehaviour>>
  + void ConsumeElectricity()
  --
}
interface ICanSelect {
  <<MonoBehaviour>>
  + void OnSelected()
  + void OnDeselected()
  --
}
interface ICanRotate {
  <<MonoBehaviour>>
  + void RotateStructure()
}
interface IDamageable {
  + void TakeDamage(int amount)
}


'Enemy
interface ICanMove {
  <<MonoBehaviour>>
  + void Move()
  + void ChooseDestination()
  --
}
interface ICanAttack {
  <<MonoBehaviour>>
  + void AttackStructure()
  --
}



class Structure <<MonoBehaviour>> {
  <<MonoBehaviour>>
  # int currHp
  # int direction
  # List<Vector2Int> occupiedPositions
  --
  <<ScriptableObject>>
  + int maxHp
  + Vector2Int sizeInCells
}
Structure ..|> ICanSelect
Structure ..|> ICanRemove
Structure ..|> ICanRotate
Structure ..|> IDamageable

class Obstacle {
  <<ScriptableObject>>
  - int maxHp
  - Vector2Int sizeInCells
}
Structure <|-- Obstacle

class InteractiveObject
Structure <|-- InteractiveObject
InteractiveObject ..|> ICanBuild
InteractiveObject ..|> ICanChangeLocation

class Wall {
  --
  <<ScriptableObject>>
  - int maxHp
  - Vector2Int sizeInCells
}
InteractiveObject <|-- Wall
Wall ..|> IFindNeighbour


'Transport Structures
class Belt {
  --
  <<ScriptableObject>>
  - int maxHp
  - Vector2Int sizeInCells
}
InteractiveObject <|-- Belt
Belt ..|> IFindNeighbour
Belt ..|> ICanTransport

class Spliter {
  --
  <<ScriptableObject>>
  - int maxHp
  - Vector2Int sizeInCells
}
InteractiveObject <|-- Spliter
Spliter ..|> IFindNeighbour
Spliter ..|> ICanTransport

class Insester {
  --
  <<ScriptableObject>>
  - int maxHp
  - Vector2Int sizeInCells
}
InteractiveObject <|-- Insester
Insester ..|> IFindNeighbour
Insester ..|> ICanTransport

class ElectricPole {
  <<MonoBehaviour>>
  - void GiveElectricity()
  - void ConnectToStructures()
  --
  <<ScriptableObject>>
  - int maxHp
  - Vector2Int sizeInCells
  - Vector2Int coverageArea
}
InteractiveObject <|-- ElectricPole
ElectricPole ..|> IFindNeighbour

class Turret {
  <<MonoBehaviour>>
  - EnemyScript enemy
  --
  <<ScriptableObject>>
  - int maxHp
  - float damageScale
  - int consumeElectricityAmount
  - Vector2Int sizeInCells
}
InteractiveObject <|-- Turret
Turret ..|> ICanShoot
Turret ..|> IConsumeElectricity
Turret --> EnemyScript : use functions

class Factory {
  <<MonoBehaviour>>
  - int productCurrSpeed
  --
  <<ScriptableObject>>
  - int maxHp
  - int consumeElectricityAmount
  - Vector2Int sizeInCells
  - List<Item> inputItemList
}
InteractiveObject <|-- Factory
Factory ..|> ICanProduce
Factory ..|> ICanTake
Factory ..|> IConsumeElectricity
Factory --> Recipe


'Items
class Recipe <<ScriptableObject>> {
  # List<ItemData> inputItems
  # List<int> inputCounts
  # List<ItemData> outputItems
  # List<int> outputCounts
  # string title
  # float productionTime
  # float electricityCost
}
Recipe --> ItemData

class ItemData <<ScriptableObject>> {
  # string title
  # Sprite icon
}


'Grid
class Grid <<MonoBehaviour>> {
  <<MonoBehaviour>>
  - int[,] gridArray
  - TextMesh[,] debugTextArray
  --
  <<ScriptableObject>>
  - int width
  - int height
  - float cellSize
  - Vector3 originPosition
}
Grid --> Structure


'Enemy
class EnemyScript <<MonoBehaviour>> {
  <<MonoBehaviour>>
  + EnemyData data
  - int currHp
  -- Modules --
  + EnemyChooseActionScript chooseAction
  + EnemyMovementScript movement
  + EnemyAttackScript attack
  + EnemyAnimationScript animation
  --
}
EnemyScript ..|> ICanMove
EnemyScript ..|> ICanAttack

class EnemyData <<ScriptableObject>> {
  + string title
  + int maxHp
  + float moveSpeed
  + List<PriorityGroup> priorities
}
EnemyScript <-- EnemyData
EnemyData <-- PriorityGroup

class PriorityGroup <<SerializableStruct>> {
  + StructureScript type
  + float weight
}

class EnemyChooseActionScript <<MonoBehaviour>> {
  - IDamageable currentTarget
  + void Tnhink()
}
class EnemyMovementScript <<MonoBehaviour>> {
  - NavMeshAgent agent
  + void MoveTo(Vector3 position)
  + void Stop()
}
class EnemyAttackScript <<MonoBehaviour>> {
  + void Attack(IDamageable target)
  - float attackCooldown
}
class EnemyAnimationScript <<MonoBehaviour>> {
  + void PlayAttack()
  + void SetMoveSpeed(float speed)
}

' Relations
EnemyScript *-- EnemyChooseActionScript
EnemyScript *-- EnemyMovementScript
EnemyScript *-- EnemyAttackScript
EnemyScript *-- EnemyAnimationScript
EnemyChooseActionScript --> EnemyMovementScript : commands
EnemyChooseActionScript --> EnemyAttackScript : commands
EnemyAttackScript --> IDamageable : damages



'CardSystem
class CardSystem <<MonoBehaviour>> {
  + List<<CardData>> deckList
  - void PlaceCard()
  - void CreateGhostStructure()
  --
}
CardSystem --> CardData
class CardData <<ScriptableObject>> {
  + prefab prefab
}
CardSystem --> BuildSystem : uses function



class BuildSystem <<MonoBehaviour>> {
  + static BuildSystem Instance
  - PlaceStructure(Vector3 worldPosition)
  - void Build()
  - bool CheckPlace()
  - void Move()
}
BuildSystem --> Grid : uses functions

@enduml
